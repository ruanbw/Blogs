# Git 版本控制

## 什么是版本控制系统（VCS）

很多⼈认为 Git 难以理解的第⼀个⻔槛在于：所谓的「Git 是⼀个分布式版本控制系统」这句话的具体含义不够清楚。其实分布式版本控制系统（Distributed Version Control System - DVCS）这个定义并不难，不过⼀步⼀步来，我先告诉你，什么是版本控制系统（Version Control System - VCS）。

### 版本控制：最基本功能

版本控制系统（VCS）最基本的功能是 `版本控制` 。所谓版本控制，意思就是在⽂件的修改历程中 `保留修改历史` ，让你可以⽅便地 `撤销之前对⽂件的修改操作` 。

最简化的版本控制模型，是⼤多数主流⽂本编辑器都有的「撤销（Undo）」功能：你本来想删除⼀个字符，却在按删除键之前不⼩⼼选中了全⽂，结果⼀下⼦整篇⽂档都被删光了，没关系，按⼀下「撤销」(Ctrl + Z 或 ⌘ + Z 或 U 等等，具体和你的操作系统以及编辑器有关），删掉的⽂字就都回来了。这其实是⽂本编辑器帮你⾃动保存了之前的内容，当你按下「撤销」的时候，它就帮你把内容回退到上⼀个状态；同理，按⼀次是会退到上⼀个版本，按两次就是回退到上上⼀个版本。

写程序的时候同样也难免会遇到「写错」的情况，所以程序的VCS，当然也会需要版本控制功能，这样当你发现「昨天有⼀⾏代码写错了」，你就不⽤凭着记忆把那段代码背出来，⽽只需要在 VCS中选择撤回到昨天的那个版本。

### 主动提交：程序代码和普通⽂本的区别

VCS 和⽂本编辑器的撤销功能⽐起来，有⼀个很重要的区别是：程序代码的修改的 `⽣命周期` ⾮常⻓。⼀次代码的修改，在⼏天后、⼏个⽉后、⼏年后都有可能需要被翻出来。如果依然采⽤「每次改动⾃动保存」的形式来保留修改历史，将会导致改动历史⾮常频繁和⽆章可循，这样，历史代码的查找、阅读和回退就会很困难了。所以，和⽂本编辑器的撤销功能不同，VCS 保存修改历史，使⽤的是 `主动提交改动` 的机制。

在你写了⼀段完整的代码（例如修复了⼀个 bug）之后，使⽤commit 命令把改动和对改动的描述信息提交，这次改动就被记录到版本历史中了。之后如果你希望回退到这个版本，就可以从 VCS 的历史⽇志中⽅便地找到它。

### 中央式版本控制系统

最初的版本控制系统，是中央式版本控制系统（Centralized VCS），也就是前⾯我讲的这种。Git 是分布式的版本控制系统（Distributed VCS），现在先说⼀下中央式版本控制系统的⼯作模型。

### ⼯作模型

假设你在⼀个三⼈团队，你们计划开发⼀个软件或者系统，并决定使⽤中央式 VCS 来管理代码。于是：

- 作为项⽬的主⼯程师，你独⾃⼀⼈花两天时间搭建了项⽬的框架；

- 然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了⼀个中央仓库，并把你的代码提交到了中央仓库上；

- 你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三⼈开始并⾏开发；

- 在之后的开发过程中，你们三⼈为了⼯作⽅便，总是每⼈独⽴负责开发⼀个功能，在这个功能开发完成后，这个⼈就把他的这些新代码提交到中央仓库；

- 每次当有⼈把代码提交到中央仓库的时候，另外两个⼈就可以选择把这些代码同步到⾃⼰的机器上，保持⾃⼰的本地代码总是最新的。

⽽对于团队中的每个⼈来说，就会更简单⼀点：

- 第⼀次加⼊团队时，把中央仓库的代码取下来；

- 写完的新功能提交到中央仓库；

- 同事提交到中央仓库的新代码，及时同步下来。

这样，⼀个三⼈的团队就成功做到了各⾃在⾃⼰的电脑上开发同⼀个项⽬，并且互不影响，就好像你们三个⼈是在同⼀台电脑上操作⼀
样。

这就是中央式 VCS 最基本的⼯作模型。当然，实际的开发⼯作并没有简单到这种程度，因为你时常会需要处理代码冲突、查看版本历
史、回退代码版本等；另外，Git 属于分布式 VCS，它的概念也⽐中央式 VCS 要复杂⼀些。但这些概念你需要⼀步步地理解和吸收，你现在只需要先知道中央式 VCS 的这个基本⼯作模型。

## 什么是分布式版本控制系统

（DVCS）分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每⼀个成员的机器上都有⼀份本地仓库，这个仓库⾥包含了所有的版本历史，或者换句话说，每个⼈在⾃⼰的机器上就可以提交代码、查看历史，⽽⽆需联⽹和中央仓库交互——当然，取⽽代之的，你需要和本地仓库交互。

中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。⽽在分布式 VCS 中，保存版本历史的⼯作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这⼀个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。

### ⼯作模型

依然以三⼈团队为例，分布式 VCS 的⼯作模型⼤致是这样：

- ⾸先，你作为主⼯程师，独⽴搭建了项⽬架构，并把这些代码提交到了本地仓库；

- 然后，你在服务器上创建了⼀个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库；

- 其他同事把中央仓库的所有内容克隆到本地，拥有了各⾃的本地仓库，从此刻开始，你们三⼈开始并⾏开发；

- 在之后的开发过程中，你们三⼈总是每⼈独⽴负责开发⼀个功能，在这个功能开发过程中，⼀个⼈会把它的每⼀步改动提交到本地仓库。注意：由于本地提交⽆需⽴即上传到中央仓库，所以每⼀步提交不必是⼀个完整功能，⽽可以是功能中的⼀个步骤或块。

- 在⼀个⼈把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库；

- 每次当有⼈把新的提交推送到中央仓库的时候，另外两个⼈就可以选择把这些提交同步到⾃⼰的机器上，并把它们和⾃⼰的本地代码合并。

可以看出，这个⼯作模型和上⼀节讲的「中央式 VCS 的⼯作模型」很相似，只是把代码的提交和上传过程拆开了。另外，和上节讲的中央式 VCS ⼯作模型⼀样，这个也只是分布式VCS 的⼀个最基本的⼯作模型，实际的开发⼯作会⽐这个麻烦和复杂。但这是个核⼼模型，你把它理解了，就可以更好地看懂后⾯的内容。

## 优点与缺点

### 分布式 VCS 的优点：

- ⼤多数的操作可以在本地进⾏，所以速度更快，⽽且由于⽆需联⽹，所以即使不在公司甚⾄没有在联⽹，你也可以提交代码、查看历史，从⽽极⼤地减⼩了开发者的⽹络条件和物理位置的限制（例如，你可以在⻜机上提交代码、切换分⽀等等）；

- 由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，⽽不是⼀个提交包含很多代码，难以 review 也难以回溯。

### 分布式 VCS 的缺点：

- 由于每⼀个机器都有完整的本地仓库，所以初次获取项⽬（Git术语：clone）的时候会⽐较耗时；

- 由于每个机器都有完整的本地仓库，所以本地占⽤的存储⽐中央式 VCS 要⾼。对于⼀般的程序项⽬⽽⾔，由于项⽬的⼤多数内容都是⽂本形式的代码，所以⼯程的体积都并不是很⼤，再加上⽂本内容⾃身的特点，VCS 可以利⽤算法来把仓库的体积极⼤地压缩。这就导致，在实际中，Git 等分布式VCS 的仓库体积并不⼤，初次获取项⽬的耗时和本地仓库的存储占⽤都很⼩。所以对于⼤多数的程序项⽬⽽⾔，分布式 VCS 「尺⼨⼤、初次下载慢」的问题其实并不严重。

不过也有⼀些例外，⽐如游戏开发。游戏的开发中有⼤量的⼤尺⼨数据和媒体⽂件，并且这些⽂件的格式也不容易压缩尺⼨，如果⽤分布式 VCS 会导致仓库的体积⾮常庞⼤。所以⼀些⼤型游戏的开发会选择中央式的 VCS来管理代码

## 快速上手 Git

> 1、本地安装Git

> 2、先准备一个空的仓库,可以去[Gitee](https://gitee.com)或者[Github](https://github.com)上创建

### 把远程仓库取到本地

找一个空目录，为把远程仓库取到本地做准备

```sh
git clone [远程仓库地址]
```

不出意外的话当前⽬录下多了⼀个新的⼦⽬录，进⼊这个⽬录，你会发现这⾥有 LICENSE 和.gitignore ⽂件，还有⼀个叫做 .git 的隐藏⽬录。

这个 .git ⽬录，就是你的本地仓库（Local Repository），你的所有版本信息都会存在这⾥。⽽ .git 所在的这个根⽬录，称为 Git的⼯作⽬录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。现在你在项⽬的⽬录下输⼊：

```sh
git log
```

在这⾥你只能看到⼀个提交，这个提交是 GitHub 帮你做的，它的内容是创建你的初始 .gitignore 和 LICENSE 这两个⽂件。

### 第一次提交

你可以在⼯作⽬录下创建⼀个⽂本⽂件，例如 `demo.txt` 。

Git 的提交是⽤的 `commit` 指令。不过现在还不能直接提交。先在 `Terminal` 输⼊：

```sh
git status
```

`status` 是⽤来查看⼯作⽬录当前状态的指令：

输入 `git status` 后你会得到多项信息：

1. 你在 master branch
2. 当前 branch 没有落后于 origin/master
3. 你有 untracked files （未追踪的⽂件），⽂件名是demo.txt。
4. 你可以使⽤ git add 来开始追踪⽂件。

其中前两条你可以暂时先不理，branch 的东⻄我在后⾯会讲。关于后两条，简单说⼀下：

从上⾯的信息可以看出，demo.txt 这个⽂件⽬前属于"untracked" 状态，它的意思是 Git 仓库对它没有进⾏任何记录，你在提交的时候不会把它提交上去，查看提交历史也不会看到它。总之，对于 Git 仓库来说，它是不存在的。

⽽你现在想提交这个⽂件，所以⾸先，你需要⽤ add 指令来让 Git开始跟踪它：

```sh
git add demo.txt
```

输⼊这⾏代码，Terminal 不会给你反馈信息。但这时你再执⾏⼀次 `git status`，你会发现显示内容变了：

可以看到，demo.txt 的⽂字变成了绿⾊，它的前⾯多了「new file:」的标记，⽽它的描述也从 "Untracked files" 变成了"Changes to be commited"。这些都说明⼀点：demo.txt 这个⽂件的状态从 "untracked"（未跟踪）变成了"staged"（已暂存），意思是这个⽂件中被改动的部分（也就是这整个⽂件啦）被记录进了 staging area（暂存区）。

现在⽂件已经放进了暂存区，就可以提交了。提交的⽅式是⽤commit 指令：

```sh
git commit [提交信息]
```

下面你可以使⽤ `git push` 来把你的本地提交发布（即上传到中央仓库）。

```sh
git push
```

去到你的仓库，刷新页面，即可看到新提交的文件 `demo.txt`,还有你的提交信息

// TODO 未完待续...