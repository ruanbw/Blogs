import{_ as a,o as e,c as s,X as t}from"./chunks/framework.6e839c56.js";const b=JSON.parse('{"title":"Git 版本控制","description":"","frontmatter":{},"headers":[],"relativePath":"pages/operation/git版本控制.md","filePath":"pages/operation/git版本控制.md","lastUpdated":1694348019000}'),l={name:"pages/operation/git版本控制.md"},i=t('<h1 id="git-版本控制" tabindex="-1">Git 版本控制 <a class="header-anchor" href="#git-版本控制" aria-label="Permalink to &quot;Git 版本控制&quot;">​</a></h1><h2 id="什么是版本控制系统-vcs" tabindex="-1">什么是版本控制系统（VCS） <a class="header-anchor" href="#什么是版本控制系统-vcs" aria-label="Permalink to &quot;什么是版本控制系统（VCS）&quot;">​</a></h2><p>很多⼈认为 Git 难以理解的第⼀个⻔槛在于：所谓的「Git 是⼀个分布式版本控制系统」这句话的具体含义不够清楚。其实分布式版本控制系统（Distributed Version Control System - DVCS）这个定义并不难，不过⼀步⼀步来，我先告诉你，什么是版本控制系统（Version Control System - VCS）。</p><h3 id="版本控制-最基本功能" tabindex="-1">版本控制：最基本功能 <a class="header-anchor" href="#版本控制-最基本功能" aria-label="Permalink to &quot;版本控制：最基本功能&quot;">​</a></h3><p>版本控制系统（VCS）最基本的功能是 <code>版本控制</code> 。所谓版本控制，意思就是在⽂件的修改历程中 <code>保留修改历史</code> ，让你可以⽅便地 <code>撤销之前对⽂件的修改操作</code> 。</p><p>最简化的版本控制模型，是⼤多数主流⽂本编辑器都有的「撤销（Undo）」功能：你本来想删除⼀个字符，却在按删除键之前不⼩⼼选中了全⽂，结果⼀下⼦整篇⽂档都被删光了，没关系，按⼀下「撤销」(Ctrl + Z 或 ⌘ + Z 或 U 等等，具体和你的操作系统以及编辑器有关），删掉的⽂字就都回来了。这其实是⽂本编辑器帮你⾃动保存了之前的内容，当你按下「撤销」的时候，它就帮你把内容回退到上⼀个状态；同理，按⼀次是会退到上⼀个版本，按两次就是回退到上上⼀个版本。</p><p>写程序的时候同样也难免会遇到「写错」的情况，所以程序的VCS，当然也会需要版本控制功能，这样当你发现「昨天有⼀⾏代码写错了」，你就不⽤凭着记忆把那段代码背出来，⽽只需要在 VCS中选择撤回到昨天的那个版本。</p><h3 id="主动提交-程序代码和普通文本的区别" tabindex="-1">主动提交：程序代码和普通⽂本的区别 <a class="header-anchor" href="#主动提交-程序代码和普通文本的区别" aria-label="Permalink to &quot;主动提交：程序代码和普通⽂本的区别&quot;">​</a></h3><p>VCS 和⽂本编辑器的撤销功能⽐起来，有⼀个很重要的区别是：程序代码的修改的 <code>⽣命周期</code> ⾮常⻓。⼀次代码的修改，在⼏天后、⼏个⽉后、⼏年后都有可能需要被翻出来。如果依然采⽤「每次改动⾃动保存」的形式来保留修改历史，将会导致改动历史⾮常频繁和⽆章可循，这样，历史代码的查找、阅读和回退就会很困难了。所以，和⽂本编辑器的撤销功能不同，VCS 保存修改历史，使⽤的是 <code>主动提交改动</code> 的机制。</p><p>在你写了⼀段完整的代码（例如修复了⼀个 bug）之后，使⽤commit 命令把改动和对改动的描述信息提交，这次改动就被记录到版本历史中了。之后如果你希望回退到这个版本，就可以从 VCS 的历史⽇志中⽅便地找到它。</p><h3 id="中央式版本控制系统" tabindex="-1">中央式版本控制系统 <a class="header-anchor" href="#中央式版本控制系统" aria-label="Permalink to &quot;中央式版本控制系统&quot;">​</a></h3><p>最初的版本控制系统，是中央式版本控制系统（Centralized VCS），也就是前⾯我讲的这种。Git 是分布式的版本控制系统（Distributed VCS），现在先说⼀下中央式版本控制系统的⼯作模型。</p><h3 id="工作模型" tabindex="-1">⼯作模型 <a class="header-anchor" href="#工作模型" aria-label="Permalink to &quot;⼯作模型&quot;">​</a></h3><p>假设你在⼀个三⼈团队，你们计划开发⼀个软件或者系统，并决定使⽤中央式 VCS 来管理代码。于是：</p><ul><li><p>作为项⽬的主⼯程师，你独⾃⼀⼈花两天时间搭建了项⽬的框架；</p></li><li><p>然后，你在公司的服务器（这个服务器可以是公司内的设备，也可以是你们买的云服务）上创建了⼀个中央仓库，并把你的代码提交到了中央仓库上；</p></li><li><p>你的两个队友从中央仓库取到了你的初始代码，从此刻开始，你们三⼈开始并⾏开发；</p></li><li><p>在之后的开发过程中，你们三⼈为了⼯作⽅便，总是每⼈独⽴负责开发⼀个功能，在这个功能开发完成后，这个⼈就把他的这些新代码提交到中央仓库；</p></li><li><p>每次当有⼈把代码提交到中央仓库的时候，另外两个⼈就可以选择把这些代码同步到⾃⼰的机器上，保持⾃⼰的本地代码总是最新的。</p></li></ul><p>⽽对于团队中的每个⼈来说，就会更简单⼀点：</p><ul><li><p>第⼀次加⼊团队时，把中央仓库的代码取下来；</p></li><li><p>写完的新功能提交到中央仓库；</p></li><li><p>同事提交到中央仓库的新代码，及时同步下来。</p></li></ul><p>这样，⼀个三⼈的团队就成功做到了各⾃在⾃⼰的电脑上开发同⼀个项⽬，并且互不影响，就好像你们三个⼈是在同⼀台电脑上操作⼀ 样。</p><p>这就是中央式 VCS 最基本的⼯作模型。当然，实际的开发⼯作并没有简单到这种程度，因为你时常会需要处理代码冲突、查看版本历 史、回退代码版本等；另外，Git 属于分布式 VCS，它的概念也⽐中央式 VCS 要复杂⼀些。但这些概念你需要⼀步步地理解和吸收，你现在只需要先知道中央式 VCS 的这个基本⼯作模型。</p><h2 id="什么是分布式版本控制系统" tabindex="-1">什么是分布式版本控制系统 <a class="header-anchor" href="#什么是分布式版本控制系统" aria-label="Permalink to &quot;什么是分布式版本控制系统&quot;">​</a></h2><p>（DVCS）分布式 VCS （Distributed VCS / DVCS）和中央式的区别在于，分布式 VCS 除了中央仓库之外，还有本地仓库：团队中每⼀个成员的机器上都有⼀份本地仓库，这个仓库⾥包含了所有的版本历史，或者换句话说，每个⼈在⾃⼰的机器上就可以提交代码、查看历史，⽽⽆需联⽹和中央仓库交互——当然，取⽽代之的，你需要和本地仓库交互。</p><p>中央式 VCS 的中央仓库有两个主要功能：保存版本历史、同步团队代码。⽽在分布式 VCS 中，保存版本历史的⼯作转交到了每个团队成员的本地仓库中，中央仓库就只剩下了同步团队代码这⼀个主要任务。它的中央仓库依然也保存了历史版本，但这份历史版本更多的是作为团队间的同步中转站。</p><h3 id="工作模型-1" tabindex="-1">⼯作模型 <a class="header-anchor" href="#工作模型-1" aria-label="Permalink to &quot;⼯作模型&quot;">​</a></h3><p>依然以三⼈团队为例，分布式 VCS 的⼯作模型⼤致是这样：</p><ul><li><p>⾸先，你作为主⼯程师，独⽴搭建了项⽬架构，并把这些代码提交到了本地仓库；</p></li><li><p>然后，你在服务器上创建了⼀个中央仓库，并把 1 中的提交从本地仓库推送到了服务器的中央仓库；</p></li><li><p>其他同事把中央仓库的所有内容克隆到本地，拥有了各⾃的本地仓库，从此刻开始，你们三⼈开始并⾏开发；</p></li><li><p>在之后的开发过程中，你们三⼈总是每⼈独⽴负责开发⼀个功能，在这个功能开发过程中，⼀个⼈会把它的每⼀步改动提交到本地仓库。注意：由于本地提交⽆需⽴即上传到中央仓库，所以每⼀步提交不必是⼀个完整功能，⽽可以是功能中的⼀个步骤或块。</p></li><li><p>在⼀个⼈把某个功能开发完成之后，他就可以把这个功能相关的所有提交从本地仓库推送到中央仓库；</p></li><li><p>每次当有⼈把新的提交推送到中央仓库的时候，另外两个⼈就可以选择把这些提交同步到⾃⼰的机器上，并把它们和⾃⼰的本地代码合并。</p></li></ul><p>可以看出，这个⼯作模型和上⼀节讲的「中央式 VCS 的⼯作模型」很相似，只是把代码的提交和上传过程拆开了。另外，和上节讲的中央式 VCS ⼯作模型⼀样，这个也只是分布式VCS 的⼀个最基本的⼯作模型，实际的开发⼯作会⽐这个麻烦和复杂。但这是个核⼼模型，你把它理解了，就可以更好地看懂后⾯的内容。</p><h2 id="优点与缺点" tabindex="-1">优点与缺点 <a class="header-anchor" href="#优点与缺点" aria-label="Permalink to &quot;优点与缺点&quot;">​</a></h2><h3 id="分布式-vcs-的优点" tabindex="-1">分布式 VCS 的优点： <a class="header-anchor" href="#分布式-vcs-的优点" aria-label="Permalink to &quot;分布式 VCS 的优点：&quot;">​</a></h3><ul><li><p>⼤多数的操作可以在本地进⾏，所以速度更快，⽽且由于⽆需联⽹，所以即使不在公司甚⾄没有在联⽹，你也可以提交代码、查看历史，从⽽极⼤地减⼩了开发者的⽹络条件和物理位置的限制（例如，你可以在⻜机上提交代码、切换分⽀等等）；</p></li><li><p>由于可以提交到本地，所以你可以分步提交代码，把代码提交做得更细，⽽不是⼀个提交包含很多代码，难以 review 也难以回溯。</p></li></ul><h3 id="分布式-vcs-的缺点" tabindex="-1">分布式 VCS 的缺点： <a class="header-anchor" href="#分布式-vcs-的缺点" aria-label="Permalink to &quot;分布式 VCS 的缺点：&quot;">​</a></h3><ul><li><p>由于每⼀个机器都有完整的本地仓库，所以初次获取项⽬（Git术语：clone）的时候会⽐较耗时；</p></li><li><p>由于每个机器都有完整的本地仓库，所以本地占⽤的存储⽐中央式 VCS 要⾼。对于⼀般的程序项⽬⽽⾔，由于项⽬的⼤多数内容都是⽂本形式的代码，所以⼯程的体积都并不是很⼤，再加上⽂本内容⾃身的特点，VCS 可以利⽤算法来把仓库的体积极⼤地压缩。这就导致，在实际中，Git 等分布式VCS 的仓库体积并不⼤，初次获取项⽬的耗时和本地仓库的存储占⽤都很⼩。所以对于⼤多数的程序项⽬⽽⾔，分布式 VCS 「尺⼨⼤、初次下载慢」的问题其实并不严重。</p></li></ul><p>不过也有⼀些例外，⽐如游戏开发。游戏的开发中有⼤量的⼤尺⼨数据和媒体⽂件，并且这些⽂件的格式也不容易压缩尺⼨，如果⽤分布式 VCS 会导致仓库的体积⾮常庞⼤。所以⼀些⼤型游戏的开发会选择中央式的 VCS来管理代码</p><h2 id="快速上手-git" tabindex="-1">快速上手 Git <a class="header-anchor" href="#快速上手-git" aria-label="Permalink to &quot;快速上手 Git&quot;">​</a></h2><blockquote><p>1、本地安装Git</p></blockquote><blockquote><p>2、先准备一个空的仓库,可以去<a href="https://gitee.com" target="_blank" rel="noreferrer">Gitee</a>或者<a href="https://github.com" target="_blank" rel="noreferrer">Github</a>上创建</p></blockquote><h3 id="把远程仓库取到本地" tabindex="-1">把远程仓库取到本地 <a class="header-anchor" href="#把远程仓库取到本地" aria-label="Permalink to &quot;把远程仓库取到本地&quot;">​</a></h3><p>找一个空目录，为把远程仓库取到本地做准备</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">clone</span><span style="color:#BABED8;"> [远程仓库地址]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>不出意外的话当前⽬录下多了⼀个新的⼦⽬录，进⼊这个⽬录，你会发现这⾥有 LICENSE 和.gitignore ⽂件，还有⼀个叫做 .git 的隐藏⽬录。</p><p>这个 .git ⽬录，就是你的本地仓库（Local Repository），你的所有版本信息都会存在这⾥。⽽ .git 所在的这个根⽬录，称为 Git的⼯作⽬录（Working Directory），它保存了你当前从仓库中签出（checkout）的内容。现在你在项⽬的⽬录下输⼊：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">log</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>在这⾥你只能看到⼀个提交，这个提交是 GitHub 帮你做的，它的内容是创建你的初始 .gitignore 和 LICENSE 这两个⽂件。</p><h3 id="第一次提交" tabindex="-1">第一次提交 <a class="header-anchor" href="#第一次提交" aria-label="Permalink to &quot;第一次提交&quot;">​</a></h3><p>你可以在⼯作⽬录下创建⼀个⽂本⽂件，例如 <code>demo.txt</code> 。</p><p>Git 的提交是⽤的 <code>commit</code> 指令。不过现在还不能直接提交。先在 <code>Terminal</code> 输⼊：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">status</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p><code>status</code> 是⽤来查看⼯作⽬录当前状态的指令：</p><p>输入 <code>git status</code> 后你会得到多项信息：</p><ol><li>你在 master branch</li><li>当前 branch 没有落后于 origin/master</li><li>你有 untracked files （未追踪的⽂件），⽂件名是demo.txt。</li><li>你可以使⽤ git add 来开始追踪⽂件。</li></ol><p>其中前两条你可以暂时先不理，branch 的东⻄我在后⾯会讲。关于后两条，简单说⼀下：</p><p>从上⾯的信息可以看出，demo.txt 这个⽂件⽬前属于&quot;untracked&quot; 状态，它的意思是 Git 仓库对它没有进⾏任何记录，你在提交的时候不会把它提交上去，查看提交历史也不会看到它。总之，对于 Git 仓库来说，它是不存在的。</p><p>⽽你现在想提交这个⽂件，所以⾸先，你需要⽤ add 指令来让 Git开始跟踪它：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">add</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">demo.txt</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>输⼊这⾏代码，Terminal 不会给你反馈信息。但这时你再执⾏⼀次 <code>git status</code>，你会发现显示内容变了：</p><p>可以看到，demo.txt 的⽂字变成了绿⾊，它的前⾯多了「new file:」的标记，⽽它的描述也从 &quot;Untracked files&quot; 变成了&quot;Changes to be commited&quot;。这些都说明⼀点：demo.txt 这个⽂件的状态从 &quot;untracked&quot;（未跟踪）变成了&quot;staged&quot;（已暂存），意思是这个⽂件中被改动的部分（也就是这整个⽂件啦）被记录进了 staging area（暂存区）。</p><p>现在⽂件已经放进了暂存区，就可以提交了。提交的⽅式是⽤commit 指令：</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">commit</span><span style="color:#BABED8;"> [提交信息]</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>下面你可以使⽤ <code>git push</code> 来把你的本地提交发布（即上传到中央仓库）。</p><div class="language-sh line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">git</span><span style="color:#BABED8;"> </span><span style="color:#C3E88D;">push</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>去到你的仓库，刷新页面，即可看到新提交的文件 <code>demo.txt</code>,还有你的提交信息</p><p>// TODO 未完待续...</p>',61),o=[i];function p(n,r,c,d,h,u){return e(),s("div",null,o)}const C=a(l,[["render",p]]);export{b as __pageData,C as default};
